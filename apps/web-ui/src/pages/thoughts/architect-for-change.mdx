---
layout: "../../components/blog/post.astro"
title: "Architect for Change"
publishedDate: "Tue Dec 19 01:27:55 PM CST 2023"
draft: false
---

# Context
In a traditional Computer Science  program, you'll learn ways to build
software in a "pure" sense. In the business world, constraints prevent you from 
holding to those patterns/goals. This is an exploration of how we can design a 
software system (in this case, a web UI) to be ready for the change in requirements
a business will likely serve it.

# 
Consider a portion of a large form, the user is prompted to select an item from
a list of existing things, once selected, the user can choose a set of characteristics
of that selected thing to include. The portion of interest would look something
like: 

```tsx
// form.tsx
const [choice, setChoice] = React.useState<Thing | null>(null);

<select onChange={(e) => void setChoice(e.target.value)}>
  {options.map((option) => <option key={option.id} />}
</select>

{Boolean(choice) && (
    <div>
       <Checkbox label="Users" />
       ...
       <Checkbox label="Rules" />
    </div>
)}
```

Now, there's all sorts of ways in which you might architect this component and
the components around it. One traditionally React way would be to have a top-level
"container" that owns the state of the form and distributes values and callback
to the various children "components".

Consider the following as an implementation of that idea:

```
 /src
 │ FormContainer.tsx
 │ ThingSelect.tsx
 └ Checkbox.tsx
```

Further, the list of `Things` is data coming from a server, the container will
use a hook that fetches that data.

```tsx
const { things, loading } = useThings();
```

Now the container might look like:

```tsx
// /src/FormContainer.tsx
const { things, loading } = useThings();
const [choice, setChoice] = React.useState<Thing | null>(null);

return (
    <ThingSelect 
      options={things}
      choice={choice}
      setChoice(setChoice)
      disabled={loading}
    />
    {Boolean(choice) && (
      <div>
        <Checkbox label="Users" />
        ...
        <Checkbox label="Rules" />
      </div>
    )}
)
```

To conceptualize the checkbox selection, the details of the state is rather
arbitrary and may be informed by the server's expectations on the form submission.
I'm not convinced its relevant to this exploration. To avoid disctraction,
consider a derived value of `isUsersSelected` as a stand-in to represent the
state relevant to first checkbox.

Now, consider a new requirement, when the user has selected one of the checkboxes,
we want to display some additional context about the implications/details of that
choice. Imagine, as a first step, we want to show the number of Users the selected
Thing has which will be included. This data will need to be fetched from the server.

To continue our container/component pattern we established, FormContainer will
change to:

```tsx
// /src/FormContainer.tsx
const { things, loading } = useThings();
const [choice, setChoice] = React.useState<Thing | null>(null);

const { userCount, loadingUserCount } = useUserCount(choice.id);

return (
    <ThingSelect 
      options={things}
      choice={choice}
      setChoice(setChoice)
      disabled={loading}
    />
    {Boolean(choice) && (
      <div>
        <Checkbox label="Users" />
        ...
        <Checkbox label="Rules" />
      </div>
    )}
    {isUsersSelected && (
      <>
        {loadingUserCount && <Spinner />}
        {!loadingUserCount && (
            <span>{userCount} users will be included</span>
        )}
      </>
    )}
)
```

We might want to encapsulate the UserCount rendering into its own presentational
components (and imagine there is something equivalent for each checkbox.

```tsx
// /src/FormContainer.tsx
const { things, loading } = useThings();
const [choice, setChoice] = React.useState<Thing | null>(null);

const { userCount, loadingUserCount } = useUserCount(choice.id);
...
const { rulesCount, loadingRulesCount } = useRulesCount(choice.id);

return (
    <ThingSelect 
      options={things}
      choice={choice}
      setChoice(setChoice)
      disabled={loading}
    />
    {Boolean(choice) && (
      <div>
        <Checkbox label="Users" />
        ...
        <Checkbox label="Rules" />
      </div>
    )}
    {isUsersSelected && (
      <UserCount userCount={userCount} loading={loadingUserCount} />
    )}
    ...
    {isRulesSelected && (
      <RulesCount rulesCount={rulesCount} loading={loadingRulesCount} />
    )}
)
```

You can see that the container has expanded its scope to include the logic of
the new requirement and we've created few simple presentation components to handle
the visuals. This is in alignment with the container/component pattern and works
for this situation. The challenge begins to arise as the requirements evolve
(in a contrived way, of course) and as the scale increases.

The story continues, now, in addition to the user count, we want the user to be
able to click on that count and see the list of user's names and emails.

Perhaps you can see how this starts to challenge the pure container/component
pattern. The pattern will still support this change, but doesn't seem to "thrive"
with it. Consider the changes required to support this change.

- the container needs a new hook for fetching the list of users
- the container needs a new state value for determining if the user list "modal"
is open/closed
- a new presentational component is needed to display the user list

What if that list is long and needs to be virtualized, or paginated? What if 
that list should be searchable/filterable so a user can quickly be found?

